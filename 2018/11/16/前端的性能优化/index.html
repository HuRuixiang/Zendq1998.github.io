<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>

  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.3">


  <link rel="mask-icon" href="/images/favicon.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="JavaScript,网络,Browser,DOM," />










<meta name="description" content="详解web前端性能优化（从请求到渲染）">
<meta name="keywords" content="JavaScript,网络,Browser,DOM">
<meta property="og:type" content="article">
<meta property="og:title" content="前端的渲染过程及其性能优化">
<meta property="og:url" content="https://zendq1998.github.io/2018/11/16/前端的性能优化/index.html">
<meta property="og:site_name" content="Zendq&#39;s blog">
<meta property="og:description" content="详解web前端性能优化（从请求到渲染）">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006GC8NZgy1fxpvvg0h3vj30p209amxq.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006GC8NZgy1fxpylbk6voj30sc0gaq4h.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006GC8NZly1fxqcui08gkj30um0h3q5r.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006GC8NZgy1fxqdyd5jljj30o601nwem.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006GC8NZgy1fxqdzscw9lj30g2087q3s.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006GC8NZgy1fxqeyy9erjj30oe0bh405.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006GC8NZgy1fxraxnby0mj30ux0j0jt9.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006GC8NZgy1fxrazpnl2mj30u403xjrg.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006GC8NZgy1fxrb0gceo8j30up03yjrh.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006GC8NZgy1fxrb12y66gj30uc03oq30.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006GC8NZgy1fxrdhzhpcjj30hf04g74j.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006GC8NZgy1fxrdn61k7mj30ob069gm7.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006GC8NZgy1fxrdquu5pxj30o707074z.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006GC8NZgy1fxrdvnykc5j30o707074z.jpg">
<meta property="og:updated_time" content="2018-12-02T06:37:55.682Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端的渲染过程及其性能优化">
<meta name="twitter:description" content="详解web前端性能优化（从请求到渲染）">
<meta name="twitter:image" content="https://ws1.sinaimg.cn/large/006GC8NZgy1fxpvvg0h3vj30p209amxq.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zendq1998.github.io/2018/11/16/前端的性能优化/"/>





  <title>前端的渲染过程及其性能优化 | Zendq's blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?5cdaf8a30f85728351873e45d9fe93d8";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/Zendq1998"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png" alt="Fork me on GitHub"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zendq's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">from CCNU</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zendq1998.github.io/2018/11/16/前端的性能优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zendeqin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Lufy.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zendq's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">前端的渲染过程及其性能优化</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-16T00:00:00+08:00">
                2018-11-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,069
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  26
                </span>
              
            </div>
          

          
              <div class="post-description">
                  详解web前端性能优化（从请求到渲染）
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="从浏览器发起请求到页面渲染出来的五个主要阶段"><a href="#从浏览器发起请求到页面渲染出来的五个主要阶段" class="headerlink" title="从浏览器发起请求到页面渲染出来的五个主要阶段"></a>从浏览器发起请求到页面渲染出来的五个主要阶段</h1><ol>
<li>DNS 查询</li>
<li>TCP 连接</li>
<li>HTTP 请求即响应</li>
<li>服务器响应</li>
<li>客户端渲染</li>
</ol>
<h1 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h1><h2 id="浏览器端开始请求"><a href="#浏览器端开始请求" class="headerlink" title="浏览器端开始请求"></a>浏览器端开始请求</h2><ol>
<li><p>输入提示</p>
<p>从浏览器地址框输入一个 g ，浏览器会根据你的历史访问，书签等，给出输入建议，假如说我以前打开过 google.com，浏览器就会根据它的算法匹配并给出几条建议地址。</p>
</li>
<li><p>url 解析</p>
<p> 当协议或主机名不合法时，也就是不符合 URL 格式，比如输入几个单词，中文等。浏览器会将地址栏中输入的文字传给默认的搜索引擎。</p>
<p> 合法的 URL 格式:</p>
<p> <code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;</code></p>
</li>
</ol>
<h2 id="什么是DNS解析"><a href="#什么是DNS解析" class="headerlink" title="什么是DNS解析"></a>什么是DNS解析</h2><p>简单来说，就是域名转换成ip地址的过程</p>
<h2 id="为什么要DNS解析"><a href="#为什么要DNS解析" class="headerlink" title="为什么要DNS解析"></a>为什么要DNS解析</h2><p>因为 http 是基于 tcp 连接的，而 tcp 则是通过 ip 地址去识别访问的。所以一定要找到服务器的ip地址。</p>
<h2 id="DNS域名解析过程"><a href="#DNS域名解析过程" class="headerlink" title="DNS域名解析过程"></a>DNS域名解析过程</h2><ol>
<li><p>查找浏览器缓存</p>
<p>浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束，没有则下一步。浏览器缓存域名也是有限制的，不仅浏览器缓存大小有限制，而且缓存的时间也有限制，通常情况下为几分钟到几小时不等。这个缓存时间太长和太短都不好，如果缓存时间太长，一旦域名被解析到的IP有变化，会导致被客户端缓存的域名无法解析到变化后的IP地址，以致该域名不能正常解析，这段时间内有可能会有一部分用户无法访问网站。如果时间设置太短，会导致用户每次访问网站都要重新解析一次域名。</p>
<p>打开 <code>chrome://net-internals/#dns</code> 即可查看本机浏览器的 dns 缓存。</p>
</li>
<li><p>查找系统缓存</p>
<p> 如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存中是否有这个域名对应的DNS解析结果,浏览器会调用一个类似 gethostbyname 的库函数，此函数会先去检测本地 hosts 文件，查看是否有对应 ip。例如，<code>localhost</code> 默认 ip 是 <code>172.0.0.1</code>。</p>
</li>
<li><p>路由器缓存、ISP 缓存</p>
<p>如果浏览器和系统缓存都没有，系统的 gethostname 函数就会像 DNS 服务器发送请求。而网络服务一般都会先经过路由器以及网络服务商（电信），所以会先查询路由器缓存，然后再查询 ISP 的 DNS 缓存。也就是本地区的域名服务器，通常是提供给你接入互联网的应用提供商。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受域名的失效时间控制的，一般缓存空间不是影响域名失效的主要因素。</p>
</li>
<li><p>递归搜索</p>
<p> 最无奈的情况发生了, 在前面都没有办法命中的DNS缓存的情况下,(1)本地 DNS服务器即将该请求转发到互联网上的根域(.)，通常省略不写。(2)根域将所要查询域名中的顶级域（.com, .org）的服务器IP地址返回到本地DNS。(3) 本地DNS根据返回的IP地址，再向顶级域（就是com域）发送请求。(4) com域服务器再将域名中的二级域（google.com）的IP地址返回给本地DNS。(5) 本地DNS再向二级域发送请求进行查询。(6) 之后不断重复这样的过程，直到本地DNS服务器得到最终的查询结果，并返回到主机。这时候主机才能通过域名访问该网站。</p>
<p> 如果域名正常，应该就会返回 IP 地址，如果没有浏览器就会提示找不到服务器地址。</p>
</li>
</ol>
<h2 id="DNS有关的性能优化"><a href="#DNS有关的性能优化" class="headerlink" title="DNS有关的性能优化"></a>DNS有关的性能优化</h2><p>DNS 查询的过程经历了很多的步骤，如果每次都如此，是不是会耗费太多的时间，资源。所以我们应该尽早的返回真实的 IP 地址，减少查询过程，也就是 DNS 缓存。浏览器获取到 IP 地址后，一般都会加到浏览器的缓存中，本地的 DNS 缓存服务器，也可以去记录。</p>
<ol>
<li><p>减少DNS查找，避免重定向</p>
<ul>
<li>服务器可以设置TTL值表示DNS记录的存活时间。本机DNS缓存将根据这个TTL值判断DNS记录什么时候被抛弃，这个TTL值一般都不会设置很大，主要是考虑到快速故障转移的问题。</li>
<li>浏览器DNS缓存也有自己的过期时间，这个时间是独立于本机DNS缓存的，相对也比较短，例如chrome只有1分钟左右。</li>
<li>浏览器DNS记录的数量也有限制，如果短时间内访问了大量不同域名的网站，则较早的DNS记录将被抛弃，必须重新查找。不过即使浏览器丢弃了DNS记录，操作系统的DNS缓存也有很大机率保留着该记录，这样可以避免通过网络查询而带来的延迟。</li>
</ul>
</li>
<li><p>DNS的预解析</p>
<ul>
<li><p>可以通过用meta信息来告知浏览器, 我这页面要做DNS预解析</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>使用link标签来强制对DNS做预解析:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://ke.qq.com/&quot; /&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h1 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h1><p>待总结~~</p>
<h1 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h1><p>待总结~~</p>
<h1 id="浏览器的渲染"><a href="#浏览器的渲染" class="headerlink" title="浏览器的渲染"></a>浏览器的渲染</h1><h2 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h2><p><a href="浏览器的工作原理">参考文章</a></p>
<h2 id="浏览器的主要组件"><a href="#浏览器的主要组件" class="headerlink" title="浏览器的主要组件"></a>浏览器的主要组件</h2><ol>
<li>用户界面：除了浏览器主窗口显示的你请求的页面之外，其他的各个部分都属于用户界面。</li>
<li>渲染引擎：负责显示请求的内容。如果请求的内容是HTML，它就负责解析HTML和CSS内容，并将解析后的内容显示在屏幕上。</li>
<li>浏览器引擎：在用户界面与渲染引擎之间传送指令。</li>
<li>网络：用于网络调用，比如HTTP请求，其接口与平台无关，并为所有平台提供底层实现。</li>
<li>用户界面后端：用于绘制基本的窗口小部件，比如组合框和窗口。</li>
<li>JavaScript解释器：用于解析和执行JavaScript代码。</li>
<li>数据存储</li>
</ol>
<h2 id="两种渲染引擎"><a href="#两种渲染引擎" class="headerlink" title="两种渲染引擎"></a>两种渲染引擎</h2><p>Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的渲染引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。</p>
<p>WebKit 是一种开放源代码渲染引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。</p>
<h2 id="关键渲染路径"><a href="#关键渲染路径" class="headerlink" title="关键渲染路径"></a>关键渲染路径</h2><p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/?hl=zh-cn" target="_blank" rel="external">摘自</a></p>
<ol>
<li>处理 HTML 标记并构建 DOM 树。</li>
<li>处理 CSS 标记并构建 CSSOM 树。</li>
<li>将 DOM 与 CSSOM 合并，计算可见节点形成 <code>render tree</code></li>
<li>根据渲染树来布局，计算每个节点的位置</li>
<li>调用GPU绘制，合成图层，将每个节点转化为实际像素绘制到视口上（栅格化）</li>
</ol>
<ul>
<li><p>WebKit主流程<br><img src="https://ws1.sinaimg.cn/large/006GC8NZgy1fxpvvg0h3vj30p209amxq.jpg" alt=""></p>
</li>
<li><p>Firefox的Gecko呈现引擎的主流程<br><img src="https://ws1.sinaimg.cn/large/006GC8NZgy1fxpylbk6voj30sc0gaq4h.jpg" alt=""></p>
</li>
</ul>
<p>可以看出，虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。</p>
<p><strong><em>优化关键渲染路径</em></strong>就是指最大限度缩短执行上述第 1 步至第 5 步耗费的总时间。 这样一来，就能尽快将内容渲染到屏幕上，此外还能缩短首次渲染后屏幕刷新的时间，即为交互式内容实现更高的刷新率。</p>
<h2 id="构建对象模型（Constructing-the-Object-Model）"><a href="#构建对象模型（Constructing-the-Object-Model）" class="headerlink" title="构建对象模型（Constructing the Object Model）"></a>构建对象模型（Constructing the Object Model）</h2><p>浏览器渲染页面前需要先构建 DOM 和 CSSOM 树。因此，我们需要确保尽快将 HTML 和 CSS 都提供给浏览器。</p>
<ul>
<li><p>文档对象模型 (DOM)</p>
<p>  <img src="https://ws1.sinaimg.cn/large/006GC8NZly1fxqcui08gkj30um0h3q5r.jpg" alt=""></p>
</li>
</ul>
<pre><code>1. **字节转换字符：** 浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的制定编码（如UTF-8）将它们转换成各个字符。
2. **令牌化：** 浏览器将字符串转换成 W3C HTML5标准规定的各种令牌，例如，``&lt;html&gt;``、``&lt;body&gt;``，以及其他尖括号内的字符串。每个令牌都有特殊的规则。
3. **词法分析：** 将令牌转换成定义其属性和规则的“对象”。
4. **DOM树构建：** 最后，由于HTML标记定义不同标记之间的关系，创建的对象连接在一个树数据结构内，此结构也会捕捉原始标记中定义的父-子关系。

整个流程最终输出的是我们的文档对象模型(DOM)，浏览器对页面进行的所有进一步处理都会用到它。
</code></pre><ul>
<li><p>CSS 对象模型 (CSSOM)</p>
<p>  在浏览器构建我们的<code>DOM</code>时，在文档的 head 部分遇到了一个 link 标记，该标记引用一个外部 CSS 样式表。由于预见到需要利用该资源来渲染页面，它会立即发出对该资源的请求。</p>
<p>  与处理 HTML 时一样，我们需要将收到的 CSS 规则转换成某种浏览器能够理解和处理的东西，因此我们会重复构建对象模型过程。</p>
<p>  <img src="https://ws1.sinaimg.cn/large/006GC8NZgy1fxqdyd5jljj30o601nwem.jpg" alt=""></p>
<p>  CSS 字节转换为字符串，接着转换成令牌和节点，最后转换为一个 CSSOM 树结构内：</p>
<p>  <img src="https://ws1.sinaimg.cn/large/006GC8NZgy1fxqdzscw9lj30g2087q3s.jpg" alt=""></p>
<p>  CSSOM 为何具有树结构？为页面上的任何对象计算最后一组样式时，浏览器都会先从适用于该节点的最通用规则开始（例如，如果该节点是 body 元素的子项，则应用所有 body 样式），然后通过应用更具体的规则（即规则“向下级联”）以递归方式优化计算的样式。</p>
<p>  以上面的 CSSOM 树为例进行更具体的阐述。span 标记内包含的任何置于 body 元素内的文本都将具有 16 像素字号，并且颜色为红色 — font-size 指令从 body 向下级联至 span。不过，如果某个 span 标记是某个段落 (p) 标记的子项，则其内容将不会显示。</p>
<p>  还请注意，以上树并非完整的 CSSOM 树，它只显示了我们决定在样式表中替换的样式。每个浏览器都提供一组默认样式（也称为“User Agent 样式”）。</p>
</li>
</ul>
<h2 id="渲染树（Render-Tree）构建、布局及绘制"><a href="#渲染树（Render-Tree）构建、布局及绘制" class="headerlink" title="渲染树（Render-Tree）构建、布局及绘制"></a>渲染树（Render-Tree）构建、布局及绘制</h2><p>CSSOM 树和 DOM 树合并成渲染树，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上。优化上述每一个步骤对实现最佳渲染性能至关重要。</p>
<ul>
<li><p>第一步：将 DOM 和 CSSOM 合并成一个渲染树，网罗网页上所有可见的 DOM 内容，以及每个节点的所有 CSSOM 样式信息。</p>
<p>  <img src="https://ws1.sinaimg.cn/large/006GC8NZgy1fxqeyy9erjj30oe0bh405.jpg" alt=""></p>
<p>  为构建渲染树，浏览器大体上完成了下列工作：</p>
<ol>
<li>从DOM树的根节点开始遍历每个可见节点（脚本标记、元标记等，“display: none”属性）。</li>
<li>对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们（找的方式见上面的CSSOM讲解）。</li>
<li>连同可见节点内容和计算的样式发射该可见节点。</li>
</ol>
</li>
<li><p>第二步：布局</p>
<p>  有了渲染树，我们进入“布局阶段”，即计算节点们在设备视口内的确切位置和大小，也称为“自动重拍”。</p>
<p>  为了弄清楚每个对象在网页上的确切大小和位置，浏览器从渲染树的根节点开始进行遍历。渲染引擎会精确地捕获每个元素在视口内的确切位置和尺寸（所有相对测量值都会转换为屏幕上的绝对元素。</p>
</li>
<li><p>第三步：绘制（栅格化）：将渲染树中的每个节点转换成屏幕上的实际像素</p>
<ol>
<li>捕获渲染树以及元素位置和尺寸计算。</li>
<li>布局完成后，浏览器会立即调用 GPU 发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。</li>
</ol>
</li>
</ul>
<p>执行渲染树构建、布局和绘制所需的时间将取决于文档大小、应用的样式，以及运行文档的设备：文档越大，浏览器需要完成的工作就越多；样式越复杂，绘制需要的时间就越长（例如，单色的绘制开销“较小”，而阴影的计算和渲染开销则要“大得多”）。</p>
<p>如果 DOM 或 CSSOM 被修改，您只能再执行一遍以上所有步骤，以确定哪些像素需要在屏幕上进行重新渲染。</p>
<h2 id="阻塞渲染的CSS（Render-Blocking-CSS）"><a href="#阻塞渲染的CSS（Render-Blocking-CSS）" class="headerlink" title="阻塞渲染的CSS（Render-Blocking CSS）"></a>阻塞渲染的CSS（Render-Blocking CSS）</h2><p>默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕（CSSOM 构建完毕才会开始渲染）。请务必精简您的 CSS，尽快提供它，并利用媒体类型和查询来解除对渲染的阻塞。</p>
<p>在渲染树构建中，我们看到关键渲染路径要求我们同时具有 DOM 和 CSSOM 才能构建渲染树。这会给性能造成严重影响：HTML 和 CSS 都是阻塞渲染的资源。 HTML 显然是必需的，因为如果没有 DOM，我们就没有可渲染的内容，但 CSS 的必要性可能就不太明显，因为我们没有 CSS 也会渲染成一个网页（尽管样子很丑。。</p>
<ul>
<li><p>CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。</p>
<p>  例如：如果我们有一些 CSS 样式只在特定条件下（例如显示网页或将网页投影到大型显示器上时）使用，又该如何？如果这些资源不阻塞渲染，该有多好。</p>
<p>  我们可以通过 CSS“媒体类型”和“媒体查询”来解决这类用例：</p>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span>    <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"all"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"print.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"print"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"portrait.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"orientation:portrait"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"other.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"(min-width: 40em)"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>  上面的第一个样式表声明未提供任何媒体类型或查询，因此它适用于所有情况，也就是说，它始终会阻塞渲染。第二个声明同样阻塞渲染：“all”是默认类型，如果您不指定任何类型，则隐式设置为“all”。因此，第一个声明和第二个声明实际上是等效的。第三个样式表则不然，它只在打印内容时适用—或许您想重新安排布局、更改字体等等，因此在网页首次加载时，该样式表不需要阻塞渲染。第四个声明具有动态媒体查询，将在网页加载时计算。根据网页加载时设备的方向，portrait.css 可能阻塞渲染，也可能不阻塞渲染。最后一个样式表声明提供由浏览器执行的“媒体查询”：符合条件时，浏览器将阻塞渲染，直至样式表下载并处理完毕。</p>
<p>  最后，请注意“阻塞渲染”仅是指该CSS资源准备就绪了才开始网页的首次渲染。无论哪一种情况，浏览器仍会下载该 CSS，只不过不阻塞渲染的资源优先级较低罢了。</p>
</li>
</ul>
<h2 id="使用JavaScript添加交互"><a href="#使用JavaScript添加交互" class="headerlink" title="使用JavaScript添加交互"></a>使用JavaScript添加交互</h2><p><a href="https://zhuanlan.zhihu.com/p/25876048" target="_blank" rel="external">参考</a></p>
<p>JavaScript可以查询和修改 DOM 和 CSSOM ，会阻止 DOM 构建和延缓网页渲染。 </p>
<p>我们的脚本在文档的何处插入，就在何处执行。当 HTML 解析器遇到一个 script 标记时，它会暂停构建 DOM，将控制权移交给 JavaScript 引擎；等 JavaScript 引擎运行完毕，浏览器会从中断的地方恢复 DOM 构建。也就是说：执行内联脚本会阻止 DOM 构建，也就延缓了首次渲染。同时，浏览器将延迟脚本执行和 DOM 构建，直至其完成 CSSOM 的下载和构建。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Do not go gentle into that good night,<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"inline"</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Old age should burn and rave at close of day;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Rage, rage against the dying of the light.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Do not go gentle into that good night,<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Old age should burn and rave at close of day;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"inline"</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Rage, rage against the dying of the light.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这样的 script 标签会阻塞 HTML 解析，无论是不是 inline-script。上面的 P 标签会从上到下解析，这个过程会被两段 JavaScript 分别打算一次（加载、执行）。</p>
<p>所以实际工程中，我们常常将 JavaScript 放到文档底部。</p>
<p>另外，因为 JavaScript 可以查询任意对象的样式，所以意味着在 CSS 解析完成，也就是 CSSOM 生成之后，JavaScript 才可以被执行。所以我们常常将 style 放到文档头部。</p>
<h3 id="异步脚本"><a href="#异步脚本" class="headerlink" title="异步脚本"></a>异步脚本</h3><p>如果我们想让页面尽快显示，那我们可以使用异步脚本。HTML5 中定义了两个定义异步脚本的方法：defer 和 async。我们来看一看他们的区别。</p>
<p><img src="https://ws1.sinaimg.cn/large/006GC8NZgy1fxraxnby0mj30ux0j0jt9.jpg" alt=""></p>
<ul>
<li>同步脚本</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>当 HTML 文档被解析时如果遇见（同步）脚本，则停止解析，先去加载脚本，然后执行，执行结束后继续解析 HTML 文档。加载的脚本是外部 JavaScript 文件，浏览器必须停下来，等待从磁盘、缓存或远程服务器获取脚本，这就可能给关键渲染路径增加数十至数千毫秒的延迟。</p>
<p><img src="https://ws1.sinaimg.cn/large/006GC8NZgy1fxrazpnl2mj30u403xjrg.jpg" alt=""></p>
<ul>
<li>defer</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app1.js"</span> <span class="attr">defer</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。</p>
<p>defer 不会改变 script 中代码的执行顺序，示例代码会按照 1、2、3 的顺序执行。所以，defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。</p>
<p><img src="https://ws1.sinaimg.cn/large/006GC8NZgy1fxrb0gceo8j30up03yjrh.jpg" alt=""></p>
<ul>
<li>async</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span> <span class="attr">async</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。</p>
<p><img src="https://ws1.sinaimg.cn/large/006GC8NZgy1fxrb12y66gj30uc03oq30.jpg" alt=""></p>
<h2 id="评估关键渲染路径"><a href="#评估关键渲染路径" class="headerlink" title="评估关键渲染路径"></a>评估关键渲染路径</h2><p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/measure-crp" target="_blank" rel="external">参考</a></p>
<p><a href="https://developers.google.com/web/tools/lighthouse/" target="_blank" rel="external">使用 Lighthouse 审查网络应用</a></p>
<p>安装<a href="https://chrome.google.com/webstore/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk" target="_blank" rel="external">Lighthouse Chrome 扩展程序</a></p>
<h3 id="使用-Navigation-Timing-API与页面加载时触发的浏览器事件"><a href="#使用-Navigation-Timing-API与页面加载时触发的浏览器事件" class="headerlink" title="使用 Navigation Timing API与页面加载时触发的浏览器事件"></a>使用 Navigation Timing API与页面加载时触发的浏览器事件</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigation_timing_API" target="_blank" rel="external">Navigation Timing API</a></p>
<ul>
<li><strong>domInteractive</strong> 表示 DOM 准备就绪的时间点。</li>
<li><strong>domContentLoaded</strong> 一般表示 DOM 和 CSSOM 均准备就绪的时间点。<br>如果没有阻塞解析器的 JavaScript，则 DOMContentLoaded 将在 domInteractive 后立即触发。</li>
<li><strong>domComplete</strong> 表示网页及其所有子资源都准备就绪的时间点。</li>
</ul>
<h2 id="分析关键渲染路径"><a href="#分析关键渲染路径" class="headerlink" title="分析关键渲染路径"></a>分析关键渲染路径</h2><p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/analyzing-crp" target="_blank" rel="external">参考</a></p>
<p>DevTools 会在底部报告 DOMContentLoaded 和 onload 事件的时间，DOMContentLoaded一般表示 DOM 和 CSSOM 均准备就绪的时间点（不包括图像的渲染），onload 事件标记的点是网页所需的所有资源均已下载并经过处理的点。</p>
<p>关键资源： 可能阻止网页首次渲染的资源<br>关键路径长度： 获取所有关键资源所需的往返次数或总时间。<br>关键字节： 实现网页首次渲染所需的总字节数，它是所有关键资源传送文件大小的总和。我们包含单个 HTML 页面的第一个示例包含一项关键资源（HTML 文档）；关键路径长度也与 1 次网络往返相等（假设文件较小），而总关键字节数正好是 HTML 文档本身的传送大小。</p>
<ul>
<li>最简单的网页（只包括 HTML 标记）</li>
</ul>
<p>T0 与 T1 之间的时间捕获的是网络和服务器处理时间。</p>
<p><img src="https://ws1.sinaimg.cn/large/006GC8NZgy1fxrdhzhpcjj30hf04g74j.jpg" alt=""></p>
<p>关键资源：html（1项）<br>关键最短路径：最少1次往返<br>关键字节：5kb</p>
<ul>
<li>添加 CSS</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006GC8NZgy1fxrdn61k7mj30ob069gm7.jpg" alt=""></p>
<p>关键资源：html + css（2项）<br>关键最短路径：最少2次往返<br>关键字节：9kb</p>
<ul>
<li>添加 JavaScript （外联）</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006GC8NZgy1fxrdquu5pxj30o707074z.jpg" alt=""></p>
<p>关键资源：html + css + JavaScript（3项）<br>关键最短路径：最少2次往返 （在获取html文档后才会获取css和js的地址）<br>关键字节：11kb（增加了JavaScript）</p>
<ul>
<li>异步脚本（向 script 标记添加“async”属性来解除对解析器的阻止）</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006GC8NZgy1fxrdvnykc5j30o707074z.jpg" alt=""></p>
<p>这种情况下，T2时就已经完成构建了所有的 DOM 和 CSSOM ，domContentLoaded 触发的时间变得更早</p>
<p>关键资源：html + css（2项，JavaScript没有必要阻止网页的首次渲染）<br>关键最短路径：最少2次往返 （在获取html文档后才会获取css和js的地址）<br>关键字节：9kb（减少了JavaScript）</p>
<h2 id="优化关键路径"><a href="#优化关键路径" class="headerlink" title="优化关键路径"></a>优化关键路径</h2><p>为尽快完成首次渲染，我们需要最大限度减小一下三种可变因素：</p>
<ul>
<li><p>关键资源的数量</p>
<p>  关键资源越少，浏览器的工作量就越小，对CPU以及其他资源的占用也就越少。</p>
</li>
<li><p>关键路径长度</p>
<p>  关键路径长度越短，加载所需的往返次数就越少。</p>
</li>
<li><p>关键字节的数量</p>
<p>  关键字节数越少，需要处理的内容就越少并让其出现在屏幕的速度就越快。</p>
</li>
</ul>
<h3 id="优化关键渲染路径的常规步骤如下"><a href="#优化关键渲染路径的常规步骤如下" class="headerlink" title="优化关键渲染路径的常规步骤如下"></a>优化关键渲染路径的常规步骤如下</h3><ol>
<li>对关键路径进行分析和特性描述</li>
<li>最大限度减少关键资源的数量：删除、延迟下载、标记为异步等</li>
<li>优化关键字节数以缩短下载时间</li>
<li>优化其余关键资源的加载顺序：尽早下载所有关键资产，以缩短关键路径长度。</li>
</ol>
<h2 id="PageSpeed-规则和建议"><a href="#PageSpeed-规则和建议" class="headerlink" title="PageSpeed 规则和建议"></a>PageSpeed 规则和建议</h2><p>消除阻塞渲染的 JavaScript 和 CSS</p>
<ul>
<li><p>优化 JavaScript 的使用</p>
<ul>
<li>首选使用异步 JavaScript 资源（使用async）</li>
<li>避免同步服务器调用（使用异步的<code>fetch</code>）</li>
<li>延迟解析任何非必需的脚本 JavaScript（即对构建首次渲染的可见内容无关紧要的脚本）（使用defer）</li>
<li>避免运行时间长的 JavaScript</li>
</ul>
</li>
<li><p>优化 CSS 的使用</p>
<ul>
<li>将 CSS 置于文档 head 标签内</li>
<li>避免使用 CSS import（因为它们会在关键路径中增加往返次数）</li>
<li>内联阻塞渲染的 CSS（可实现“一次往返”关键路径长度）</li>
</ul>
</li>
</ul>
<h1 id="静态文件优化"><a href="#静态文件优化" class="headerlink" title="静态文件优化"></a>静态文件优化</h1><h2 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h2><p><a href="https://www.jianshu.com/p/55e48032b30e" target="_blank" rel="external">参考1</a><br><a href="https://juejin.im/post/59a7725b6fb9a02497170459" target="_blank" rel="external">参考2</a></p>
<ol>
<li><p>使用base64编码代替图片</p>
<p> 将图片转换为base64编码字符串inline到页面或css中，适用于图片大小小于2KB，页面上引用图片总数不多的情况。</p>
</li>
<li><p>合并图片sprite</p>
<p> 将多个页面上用到的背景图片合并成一个大的图片在页面中引用 ，可以有效的减少请求个数，兼容性很好，但是增加开发时间、增加维护成本。</p>
</li>
<li><p>图片延迟加载（懒加载）</p>
<p> 对应图片比较多的页面，可以考虑通过js来实现图片的延迟加载，先让一部分图片优先请求下来，当用户滚动页面的时候进一步加载图片。<br> 页面中的img元素，如果没有src属性，浏览器就不会发出请求去下载图片，只有通过javascript设置了图片路径，浏览器才会发送请求。<br> 懒加载的原理就是先在页面中把所有的图片统一使用一张占位图进行占位，把正真的路径存在元素的“data-url”（这个名字起个自己认识好记的就行）属性里，要用的时候就取出来，再设置。</p>
<p> 实现步骤：</p>
<ol>
<li>首先，不要将图片地址放到src属性中，而是放到其他地方存着。</li>
<li>页面加载完成后，根据<code>scroolTop</code>判断图片是否在用户视野内，如果在，则将图片地址存放到src属性中</li>
<li><p>在滚动事件中执行第二步</p>
<p>判断图片是否在用户视野内：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 屏幕可视窗口大小</span></div><div class="line"><span class="built_in">window</span>.innerHeight</div><div class="line"><span class="comment">// 浏览器窗口顶部与文档顶部之间的距离</span></div><div class="line"><span class="built_in">window</span>.pageYoffset</div><div class="line"><span class="comment">// 元素的大小及其相对于视口的位置</span></div><div class="line">Element.getBoundingClientRect()</div></pre></td></tr></table></figure>
<p>注意：滚动事件中最好用到<a href="https://zendq1998.github.io/2018/11/19/js%E4%B9%8B%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/">防抖或节流</a></p>
<p><a href="https://github.com/mqyqingfeng/LazyLoad/blob/master/lazyload.js" target="_blank" rel="external">实现懒加载</a></p>
</li>
</ol>
</li>
<li><p>使用css、svg、canvas或iconfont代替图片</p>
<p> css方式可以用来绘制相对简单的图案来代替图片，一般使用before或者after伪元素来丰富图案的复杂度。使用css,svg,iconfont减少图片尺寸，请求数据少。</p>
</li>
<li><p>响应式图片</p>
<ul>
<li><p>通过服务器图片资源配置命名规则来获取图片</p>
<p>  <code>&lt;img src=&quot;bgimg-320.jpg&quot; /&gt;或&lt;img src=&quot;bgimg-480.jpg&quot; /&gt;</code></p>
</li>
<li><p>通过css定义来加载不同的背景bg图片</p>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">media</span> only screen and (max-width : <span class="number">480px</span>) &#123;</div><div class="line"><span class="selector-class">.img</span> &#123;<span class="attribute">background-image</span>: <span class="built_in">url</span>(bg-480.jpg);&#125;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">media</span> only screen and (max-width : <span class="number">360px</span>) &#123;</div><div class="line"><span class="selector-class">.img</span> &#123;<span class="attribute">background-image</span>: <span class="built_in">url</span>(bg-360.jpg);&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Img的srcset和sizes的方法</p>
<p>  这两个img属性是html5的属性，有浏览器的兼容问题</p>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> </span></div><div class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"img"</span>  </span></div><div class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">"imgbg-320.jpg"</span></span></div><div class="line"><span class="tag">    <span class="attr">srcset</span>=<span class="string">"imgbg-320.jpg 320w, imgbg-360.jpg 360w, imgbg-480px.jpg 480w"</span></span></div><div class="line"><span class="tag">    <span class="attr">sizes</span>=<span class="string">"(max-width: 480px) 480px, 320px"</span> </span></div><div class="line"><span class="tag">/&gt;</span></div></pre></td></tr></table></figure>
<p>  <code>src</code>:当设备不支持srcset，sizes属性时，使用这个图片<br>srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点</p>
</li>
</ul>
</li>
</ol>
<pre><code>    [响应式图片srcset](https://www.zhangxinxu.com/wordpress/2014/10/responsive-images-srcset-size-w-descriptor/)
- picture标签实现

    通过媒体查询的方式，根据页面宽度（当然也可以添加其他参考项）加载不同图片

    <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"3.jpg"</span> <span class="attr">media</span>=<span class="string">"(min-width: 320px)"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"2.jpg"</span> <span class="attr">media</span>=<span class="string">"(min-width: 480px)"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">srcset</span>=<span class="string">"1.jpg"</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></div></pre></td></tr></table></figure>
</code></pre><ol>
<li><p>预加载</p>
<p> 和图片的懒加载相反，图片预加载说白了就是将所有所需的图片提前请求加载到本地，这样后面在需要用到时就直接从缓存取图片。图片预加载的JavaScript实现原理很简单：new Image()，然后使用onload方法回调预加载完成事件，当浏览器把图片下载到本地后，之后同样的src就直接使用缓存。</p>
<p> <a href="http://web.jobbole.com/86785/" target="_blank" rel="external">实现图片预加载的三种方法</a></p>
</li>
</ol>
<h2 id="提升静态文件的加载速度"><a href="#提升静态文件的加载速度" class="headerlink" title="提升静态文件的加载速度"></a>提升静态文件的加载速度</h2><p><a href="https://wetest.qq.com/lab/view/345.html" target="_blank" rel="external">参考</a></p>
<ul>
<li><p>减少请求数——文件合并</p>
<ol>
<li>合并js脚本文件</li>
<li>合并css样式文件</li>
<li>合并css引用的图片(使用sprite雪碧图)</li>
</ol>
</li>
<li><p>减少静态文件大小——代码压缩</p>
<p>  我们在平时开发的时候，JS脚本文件和CSS样式文件中的代码，都会依据一定的代码规范（比如javascript-standard-style）来提高项目的可维护性，以及团队之间合作的效率。</p>
<p>  但是在项目发布后， 这些代码是给客户端（浏览器）识别的，此时代码的命名规范、空格缩进都已没有必要，我们可以使用工具将这些代码进行混淆和压缩，减少静态文件的大小。</p>
<p>  比如用 <code>webpack</code> 打包。</p>
</li>
<li><p>gzip</p>
<p>  <a href="https://segmentfault.com/a/1190000012571492" target="_blank" rel="external">参考</a></p>
</li>
<li><p>CDN和缓存</p>
<p>  CDN 是一个全球（或者只有国内，具体看供应商）分布式网络，它把网站内容更快地传递给服务范围内的一个具体位置，而往往这个具体的位置离实际的内容服务器距离很远。举个极端点的例子，你的网站主机在爱尔兰（海南），而你的用户则在澳大利亚（漠河）访问。这时当你的用户访问你的网站的时候，延迟会很大，把你的（静态）数据用 CDN 放到澳大利亚（漠河）则会很大程度上提高用户访问网站的体验。</p>
<p>  静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。</p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"><i class="fa fa-tag"></i> JavaScript</a>
          
            <a href="/tags/网络/" rel="tag"><i class="fa fa-tag"></i> 网络</a>
          
            <a href="/tags/Browser/" rel="tag"><i class="fa fa-tag"></i> Browser</a>
          
            <a href="/tags/DOM/" rel="tag"><i class="fa fa-tag"></i> DOM</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div id="needsharebutton-postbottom">
            <span class="btn">
              <i class="fa fa-share-alt" aria-hidden="true"></i>
            </span>
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/02/typeof和instanceof的实现原理/" rel="next" title="typeof、instanceof的实现原理">
                <i class="fa fa-chevron-left"></i> typeof、instanceof的实现原理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/11/16/浏览器的事件机制/" rel="prev" title="浏览器事件机制">
                浏览器事件机制 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/Lufy.jpg"
                alt="Zendeqin" />
            
              <p class="site-author-name" itemprop="name">Zendeqin</p>
              <p class="site-description motion-element" itemprop="description">stay hungry, stay foolish</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/Zendq1998" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:zendq1998@gmail.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://zxc0328.github.io/" title="Zindex's blog" target="_blank">Zindex's blog</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#从浏览器发起请求到页面渲染出来的五个主要阶段"><span class="nav-number">1.</span> <span class="nav-text">从浏览器发起请求到页面渲染出来的五个主要阶段</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DNS解析"><span class="nav-number">2.</span> <span class="nav-text">DNS解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器端开始请求"><span class="nav-number">2.1.</span> <span class="nav-text">浏览器端开始请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是DNS解析"><span class="nav-number">2.2.</span> <span class="nav-text">什么是DNS解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要DNS解析"><span class="nav-number">2.3.</span> <span class="nav-text">为什么要DNS解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS域名解析过程"><span class="nav-number">2.4.</span> <span class="nav-text">DNS域名解析过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS有关的性能优化"><span class="nav-number">2.5.</span> <span class="nav-text">DNS有关的性能优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP连接"><span class="nav-number">3.</span> <span class="nav-text">TCP连接</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP请求"><span class="nav-number">4.</span> <span class="nav-text">HTTP请求</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#浏览器的渲染"><span class="nav-number">5.</span> <span class="nav-text">浏览器的渲染</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#渲染引擎"><span class="nav-number">5.1.</span> <span class="nav-text">渲染引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器的主要组件"><span class="nav-number">5.2.</span> <span class="nav-text">浏览器的主要组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#两种渲染引擎"><span class="nav-number">5.3.</span> <span class="nav-text">两种渲染引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关键渲染路径"><span class="nav-number">5.4.</span> <span class="nav-text">关键渲染路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构建对象模型（Constructing-the-Object-Model）"><span class="nav-number">5.5.</span> <span class="nav-text">构建对象模型（Constructing the Object Model）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#渲染树（Render-Tree）构建、布局及绘制"><span class="nav-number">5.6.</span> <span class="nav-text">渲染树（Render-Tree）构建、布局及绘制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阻塞渲染的CSS（Render-Blocking-CSS）"><span class="nav-number">5.7.</span> <span class="nav-text">阻塞渲染的CSS（Render-Blocking CSS）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用JavaScript添加交互"><span class="nav-number">5.8.</span> <span class="nav-text">使用JavaScript添加交互</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#异步脚本"><span class="nav-number">5.8.1.</span> <span class="nav-text">异步脚本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#评估关键渲染路径"><span class="nav-number">5.9.</span> <span class="nav-text">评估关键渲染路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-Navigation-Timing-API与页面加载时触发的浏览器事件"><span class="nav-number">5.9.1.</span> <span class="nav-text">使用 Navigation Timing API与页面加载时触发的浏览器事件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分析关键渲染路径"><span class="nav-number">5.10.</span> <span class="nav-text">分析关键渲染路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优化关键路径"><span class="nav-number">5.11.</span> <span class="nav-text">优化关键路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优化关键渲染路径的常规步骤如下"><span class="nav-number">5.11.1.</span> <span class="nav-text">优化关键渲染路径的常规步骤如下</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PageSpeed-规则和建议"><span class="nav-number">5.12.</span> <span class="nav-text">PageSpeed 规则和建议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#静态文件优化"><span class="nav-number">6.</span> <span class="nav-text">静态文件优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#图片优化"><span class="nav-number">6.1.</span> <span class="nav-text">图片优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#提升静态文件的加载速度"><span class="nav-number">6.2.</span> <span class="nav-text">提升静态文件的加载速度</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zendeqin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">44.1k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共44.1k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
  </script>

  

  

  

  

  undefined
  
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"superSample":2,"width":100,"height":200,"position":"right","hOffset":60,"vOffset":-100},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body>
</html>
